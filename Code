import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Определение функции
def objective_function(x1, x2):
    return (x1 - 2)**2 + (x2 - 1)**2

# Определение функциональных ограничений
def constraint1(x1, x2):
    return x1 - 2*x2 + 1

def constraint2(x1, x2):
    return -0.25*x1**2 - x2**2 + 1

# Создание сетки для визуализации
x1_min, x1_max = -1, 4
x2_min, x2_max = -1, 4
delta = 0.5
x1_values = np.arange(x1_min, x1_max + delta, delta)
x2_values = np.arange(x2_min, x2_max + delta, delta)
x1_grid, x2_grid = np.meshgrid(x1_values, x2_values)

# Вычисление значений функции на сетке
objective_values = objective_function(x1_grid, x2_grid)

# Начало построения 3D модели
fig = plt.figure(figsize=(12, 5))

# Первый подграфик - область поиска и линии уровней функции
ax1 = fig.add_subplot(121, projection='3d')
ax1.plot_surface(x1_grid, x2_grid, objective_values, cmap='viridis', alpha=0.7)
ax1.contour(x1_grid, x2_grid, objective_values, levels=20, cmap='viridis')
ax1.set_xlabel('X1')
ax1.set_ylabel('X2')
ax1.set_zlabel('Objective Function')
ax1.set_title('Objective Function and Search Space')

# Второй подграфик - область допустимых решений
ax2 = fig.add_subplot(122, projection='3d')
ax2.plot_surface(x1_grid, x2_grid, objective_values, cmap='viridis', alpha=0.7)
ax2.contour(x1_grid, x2_grid, objective_values, levels=20, cmap='viridis')
ax2.set_xlabel('X1')
ax2.set_ylabel('X2')
ax2.set_zlabel('Objective Function')
ax2.set_title('Objective Function with Feasible Region')

# Построение области допустимых решений
x1_feasible = np.linspace(x1_min, x1_max, 100)
x2_feasible1 = (x1_feasible + 1) / 2
x2_feasible2 = np.sqrt(1 - 0.25*x1_feasible**2)
ax2.fill_between(x1_feasible, x2_feasible1, x2_feasible2, color='gray', alpha=0.5, label='Feasible Region')

# Настройка области допустимых решений
feasible_region = [(x1, x2) for x1 in x1_feasible for x2 in np.linspace(x2_feasible1[x1_feasible==x1][0], x2_feasible2[x1_feasible==x1][0], 100)]
feasible_values = [objective_function(x1, x2) for x1, x2 in feasible_region]

# Нахождение минимума функции в области допустимых решений
min_index_feasible = np.argmin(feasible_values)
min_point_feasible = feasible_region[min_index_feasible]

# Вывод точки с минимальным значением функции
ax2.scatter(*min_point_feasible, color='red', s=50, label='Minimum in Feasible Region')
ax2.legend()

# Настройка общего заголовка
plt.suptitle('Objective Function and Feasible Region')

# Отображение графика
plt.show()
